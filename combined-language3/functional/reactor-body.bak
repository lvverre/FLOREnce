#lang racket
(require syntax/parse)


(define (interpret-functional-part stx env)
  (syntax-parse stx
    [((~literal if) pred then else)
     (let ((val-pred (interpret-functional-part pred env)))
       (if val-pred
           (interpret-functional-part then env)
           (interpret-functional-part else env)))]
    [(op:id args ...)
     (let ((val-op (lookup-var-error val-op env))
           (val-args (map (lambda (arg) (interpret-functional-part arg))  (syntax->list #'(args ...)))))
       (apply val-op val-args))]
    [val:number
     (syntax-e #'val)]
    [val:string
     (syntax-e #'val)]
     [val:id
     (lookup-var-env (syntax-e #'val) env)]
     [((~literal sym) val:id)
     (syntax-e #'val)]
    ))