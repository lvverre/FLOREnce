#lang racket



(define constraint-env (make-hash
                        (list (cons 'equal? prim-equal?)
                              (cons '> prim-greater-then?)
                              (cons '< prim-smaller-then?)
                              (cons '<= prim-smaller-equal-then?)
                              (cons '>= prim-greater-equal-then?)
                              (cons 'not prim-not)
                              )))
                                 


(define (compile-constraint-rules constraints)
  (define (compile-constraint-atoms atom)
    (syntax-parse atom
      [val:number
       #'(cnst-exp val)]
      [val:string
       #'(cnst-exp val)]
      [val:boolean
       #'(bool-exp val)]
      [val:id
       #'(var-exp val)]))
    
  (define (compile-constraint constraint)
    (syntax-parse constraint
      [((~literal or) args ...)
       (let ((compiled-args (map compile-constraint (syntax->list #'(args ...)))))
       #'(or-exp compiled-args))]
      [((~literal and) args ...)
        (let ((compiled-args (map compile-constraint (syntax->list #'(args ...)))))
       #'(and-exp compiled-args))]
      [(op args ...)
       (let ((val-op (lookup-var-error op constraint-env))
             (val-args (map compile-constraint (syntax->list #'(args ...)))))
         #'(app-exp val-op val-args))]
      [_ (compile-constraint-atoms constraint)]))
  (and-exp (map compile-constraint constraints))) 
         
             
       
                  
     
      