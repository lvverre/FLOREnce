#lang br/quicklang
(define (read-syntax path port)
  (define string-tree  (port->lines port))
;  (define parse-tree (quote string-tree))
  ;(display string-tree)
  (define parse-tree (format-datums '~a string-tree))
  (define module-datum `(module functionalRE3-mod "functional_reactive_language_3.rkt"
                          ,@parse-tree))
  (display module-datum)
  (datum->syntax #f module-datum))
(provide read-syntax)

(define-macro (functionalRE3-module-begin PARSE-TREE ...)
  #'(#%module-begin
     (begin 
        PARSE-TREE ...)))
(provide (rename-out [functionalRE3-module-begin #%module-begin]))


;MAKE-EVENT
(struct node (successors) #:mutable)
(struct event-node node ())
(struct function-node node (function) )
(struct filter-node node (function) )
;(struct event (observers) #:mutable)
(define (make-event)
  (event-node '()))
(define (make-function-node function)
  (function-node '() function))

(define (make-filter-node filter-function )
  (filter-node '() filter-function))

;:=
;(define (:= var val env)
 ; (environment var val env))

;ADD-observer
(define (add-observer predecessor-node new-function)
  ;see if it is an event
  (if (node? predecessor-node)
      ;make a new node
      (let ((successor-node (make-function-node new-function)))
        ;add new node to successors of old
        (set-node-successors! predecessor-node (cons successor-node (node-successors predecessor-node)))
        ;return new node
        successor-node)
      (error "wrond type of argument given")))

(define (remove-observer predecessor-node observer-node)
  (if (node? predecessor-node)
      (if (node? observer-node)
          (set-node-successors!
           predecessor-node
           (remq observer-node (node-successors predecessor-node)))
          (error "wrong type of second argument"))
                                
      (error "wrong type of first argument")))

(define (map new-function event)
  (if (node? event)
      (let ((successor-node (make-function-node new-function))
            (successor-of-successor-node (make-event)))
        (set-node-successors! event (cons successor-node (node-successors event)))
        (set-node-successors! successor-node (cons successor-of-successor-node '()))
        successor-of-successor-node)
      (error "wrong type of argument given")))

(define (execute-node node value)
  (match node
    [(event-node _ )
     (propagate-event node value)]
    [(function-node _ function)
     (propagate-event node (function value))]
    [(filter-node _ filter)
     (when (filter value)
       (propagate-event node value))]))

(define (propagate-event node value)
  (for-each (lambda (successor)
              (execute-node successor value))
            (node-successors node)
            ))

(define (change-event event new-value)
  (propagate-event event new-value))

(define (event-or event-1 event-2 new-function)
  (if (and (node? event-1)
           (node? event-2))
      (begin
        (add-observer event-1 new-function)
        (add-observer event-2 new-function))
      (error "wrond type of argument given")))

(define (event-and event filter-function observer-function)
  (if (node? event)
      (begin
        (let* ((node-function (make-function-node observer-function))
               (node-filter (make-filter-node filter-function)))
               
          (set-node-successors! event (cons node-filter (node-successors event)))
          (set-node-successors! node-filter (cons node-function '()))
          node-function))
      (error "wrong type of argument given")))


(provide event-or add-observer define + make-event lambda change-event display map event-and > remove-observer)




